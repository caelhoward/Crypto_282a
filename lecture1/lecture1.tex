\documentclass[11pt]{article}

% Prefix for numedquestion's
\newcommand{\questiontype}{Question}


% Use this if your "written" questions are all under one section
% For example, if the homework handout has Section 5: Written Questions
% and all questions are 5.1, 5.2, 5.3, etc. set this to 5
% Use for 0 no prefix. Redefine as needed per-question.
\newcommand{\writtensection}{0}

\usepackage{amsmath, amsfonts, amsthm, amssymb}  % Some math symbols

\usepackage{centernot}
\usepackage{mathtools}

\setlength{\parindent}{0pt}

\begin{document}

\section{Complexity Theory Review}

\subsection{Complexity Classes}
The class \textbf{P} (Polynomial) is the class of decision problems that can be decided in polynomial time. The running-time must be $O(n^c)$ for some constant c.
\vspace{1em}

\textbf{Super-polynomial} time describes functions that grow at a rate faster than any polynomial, but are not necessarily exponential. For example $O(n^{\text{log}n})$ is a super-polynomial running time.

\subsection{NP Completeness}
The class \textbf{NP} (Nondeterministic Polynomial) is the class of all decision problems that:

\begin{itemize}
\item Given a witness (certificate) $\omega$, can verify, that $w \in L$ in polynomial time.
\item Can be decided by a \textit{Non-deterministic turing machine} in polynomial time
\end{itemize}
These two characterstics are equivalent.

\subsection{Decision vs Solution}
Given a decider for any problem in \textbf{NP}, we can determine a satisfying solution to the problem. For example, for the question \textit{3-color}, which asks if there is a valid 3-coloring for a graph $G$, you can produce a valid 3-coloring for the graph with polynomially many calls to the decider. 
\vspace{1em}

The strategy for doing this is as follows. For any problem in NP, you can reduce the problem to circuit satisfiability, meaning that any problem can be reduced to the problem of asking if there is an input to a specific circuit that causes the circuit to output 1. If there exists a solution, for each input bit $x_1,...,x_n$, you hardcode $x_i$ to $0$ from 1 to $n$. If the decider outputs yes, there exists a valid input with $x_i$ as $0$, else, a valid input with $x_i$ as $1$ exists. Replace $x_i$ with the correct input value and repeat for all $i$.

\subsection{Reductions}
Many cryptographic protocols rely on assumptions about the difficulty of specific problems as the backbone of the security of the protocol. They are designed in a manner such that any adversary that could break the security of the protocol could break the \textit{difficulty} of the problem. The \textbf{Diffie-Hellman} public key exchange assumes that the discrete logarithm problem is impossible to solve efficiently, and uses that to create a protocol that is secure under the \textit{assumption} that this is the case.
\vspace{1em}

The protocol is as follows:
\begin{enumerate}
\item Two parties $A$ and $B$ agree a prime order group $\mathbb{Z}_p$ and generator $g$. (Important to note that for prime order groups, any non-identity member can act as a generator for the group)
\item $A$ and $B$ select exponents ($x$, $y$) $\overset{\$}{\leftarrow} \mathbb{Z}_p$ secretly, meaning only $A$ knows $x$ and only $B$ knows $y$.
\item $A$ sends $g^x$ to $B$ and $B$ sends $g^y$ to $A$. They both produce secret key $k$ by calculateing $(g^x)^y = (g^y)^x$.
\end{enumerate}
It is important to note that everything other than $x$ and $y$ are public to any potential adversary, including the sent messages.

\section{Interactive Proofs}
\subsection{Graph Isomorphism}
Proofs allowing for interaction between two parties that include a verifier (V) and a prover (P) provide a much stronger notion of verification than classical static proofs.
\vspace{1em}

The problem of determining if two graphs are isomorphic is in NP. Given $\pi$ a permutation that labels nodes in $G_0$ to nodes of $G_1$, a verifier can easily determine if the two graphs are in fact isomorphic. On the otherhand, determining whether or now two graphs are not isomorphic is more difficult. The decision problem for this can be described as given two graphs $(G_0,G_1)$, determine if they are not isomorphic.
\vspace{1em}

The protocol for this is as follows:
\begin{enumerate}
    \item V (verifier) flips a coin and selects a bit $b$ = 0 or 1 depending on the outcome. The verifier chooses $G_b$ and creates a random permutation $\pi$ that relabels the nodes of $G_b$.
    \item The verifier sends $H = \pi(G_b)$ to the prover $(P)$.
    \item $P$ has to determine $b$ based on $H$ and sends its guess $b'$ back to $V$. (Note: We assume $P$ has a decider that is able to determine if two graphs are isomorphic. With this, it can test $H$ against both $G_0$ and $G_1$ and determine $b$ if the two graphs are non-isomorphic).
    \item This process is repeated until the verifier is confident that the two graphs are non-isomorphic.
\end{enumerate}
\subsection{Properties of Interactive Proofs}
There are two key properties of all interactive proofs:
\begin{itemize}
\item Completeness: $\forall x\in L, P$[ P convinces V ] $ > 2/3$. That is, for any $x$ in the language, the probability that $P$ convinces the verifier that $x$ is a part of the language must be greater that $2/3$.
\item Soundness: $\forall x\in L, P[\ P(x)$ convinces $V$ ] $< 1/3$. Or the prover can not convince the verifier less than a third of the time
\end{itemize}

It is important to note that both parties must agree on the protocol beforehand. The actual protocol must prove that the verifier will accept the majority of instances $\textit{only}$ if $x \in L$. Because of this, the bounds are arbitrary since the protocol can be repeated many times, and the verifier can decide whether to accept or not based on the majority. 
\end{document}
